import Schema from "../gen/Schema";
import fetch from "node-fetch";

/**
 * {{{pkg.description}}}
 * @class
 */
class {{config.name}} {
    /**
     * API token to use for requests
     * @readonly
     * @private
     */
    readonly #token?: string;

    /**
     * Base URL of the API
     * @readonly
     * @private
     */
    readonly #baseUrl: string;

    /**
     * Construct a new {{config.name}} API client
     * @param token API token to use for requests
     * @param [baseUrl="{{{config.baseUrl}}}"] Base URL of the API
     */
    public constructor(token?: string, baseUrl = "{{{config.baseUrl}}}") {
        this.#token = token;
        this.#baseUrl = baseUrl;
    }

    /**
     * Send a request to the API
     * @param operation The operation to call
     * @param pathParams Path parameters to use in the request
     * @param queryParams Query parameters to use in the request
     * @param body Body to use in the request
     * @private
     */
    #sendRequest = async <T>(operation: Schema.Operation, pathParams: Record<string, string>, queryParams: Record<string, string>, body?: any): Promise<T> => {
        const url = new URL(operation.path.replace(/^\/+/, ""), this.#baseUrl);
        for (const [key, value] of Object.entries(pathParams))
            url.pathname = url.pathname.replaceAll(`/:${key}`, `/${value}`);
        for (const [key, value] of Object.entries(queryParams))
            url.searchParams.append(key, value);
        const options: Record<string, any> = {
            method: operation.method,
            headers: {}
        };
        if (body && !["GET", "HEAD"].includes(operation.method)) {
            if (typeof body !== "string") {
                options.body = JSON.stringify(body);
                options.headers["Content-Type"] = "application/json";
            }
            else {
                options.body = body;
                options.headers["Content-Type"] = "text/plain";
            }
        }
        if (this.#token && operation.token !== undefined)
            options.headers["Authorization"] = `Bearer ${this.#token}`;
        if (operation.token !== undefined)
            options.credentials = "include";
        const response = await fetch(url.toString(), options);
        if (response.status === 204) return undefined as any;
        const text = await response.text();
        let data: T;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            data = JSON.parse(text, (key, value) => {
                // parse dates
                if (/^\d{4}-\d{2}-\d{2}T(?:\d{2}:){2}\d{2}(?:\.\d+)?(?:[a-zA-Z]+|\+\d{2}:\d{2})?$/.test(value))
                    return new Date(value);
                return value;
            });
        }
        else data = text as any;
        if (response.ok) return data;
        else throw data;
    }

    {{#namespaces}}
    public {{name}} = {
        {{#operations}}
        /**
         * {{{description}}}
         * @{{method}} {{{path}}}
         {{#allParams}}
         * @param {{name}} {{{description}}}
         {{/allParams}}
         {{#throws}}
         {{=<% %>=}}
         * @throws {<%& . %>}
         <%={{ }}=%>
         {{/throws}}
         */
         {{name}}: async ({{{tsArgs}}}): Promise<{{{returnType}}}> => {
            return await this.#sendRequest<{{{returnType}}}>({{{operation}}}, {{{params.path}}}, {{{params.query}}}, {{{params.body}}});
         },
        {{/operations}}
    } as const;
    {{/namespaces}}

    {{#operations}}
    /**
     * {{{description}}}
     * @{{method}} {{{path}}}
     {{#allParams}}
     * @param {{name}} {{{description}}}
     {{/allParams}}
     {{#throws}}
     {{=<% %>=}}
     * @throws {<%& . %>}
     <%={{ }}=%>
     {{/throws}}
     */
     public async {{name}}({{{tsArgs}}}): Promise<{{{returnType}}}> {
        return await this.#sendRequest<{{{returnType}}}>({{{operation}}}, {{{params.path}}}, {{{params.query}}}, {{{params.body}}});
     };
    {{/operations}}
}

namespace {{config.name}} {
    {{#schema.models}}
    /**
     * {{{description}}}
     */
    export interface {{name}} {
        {{#fields}}
        /**
         * {{{description}}}
         */
        {{name}}: {{{type}}};
        {{/fields}}
    }
    {{/schema.models}}

    export interface PaginatedData<T> {
        /**
         * The page items
         */
        items: T;
        /**
         * The total number of items
         */
        total: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The current page number
         */
        page: number;
    }

    export class RawResponse {
        /**
         * The headers returned by the server.
         * @readonly
         */
        readonly headers: Record<string, string>;

        /**
         * A boolean indicating whether the response was successful (status in the range `200` â€“ `299`) or not.
         */
        readonly ok: boolean

        /**
         * Indicates whether or not the response is the result of a redirect (that is, its URL list has more than one entry).
         */
        readonly redirected: boolean;

        /**
         * The status code of the response.
         * @readonly
         */
        readonly status: number;

        /**
         * The status message corresponding to the status code. (e.g., `OK` for `200`).
         * @readonly
         */
        readonly statusText: string;

        /**
         * The URL of the response.
         */
        readonly url: string;

        constructor(response: import("node-fetch").Response) {
            this.headers = Object.fromEntries(response.headers.entries());
            this.ok = response.ok;
            this.redirected = response.redirected;
            this.status = response.status;
            this.statusText = response.statusText;
            this.url = response.url;
        }
    }

    class Res {
        /**
         * API response
         */
        readonly _response: RawResponse;

        constructor(response: RawResponse) {
            this._response = response;
        }
    }

    export type ApiResponse<T> = T & Res;

    export function makeApiResponse<T>(data: T, response: RawResponse): ApiResponse<T> {
        return Object.assign(new Res(response), data);
    }
}

export default {{config.name}};
